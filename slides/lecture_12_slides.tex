\documentclass[12pt]{beamer}
\usepackage{xcolor}
\usepackage{pgf,pgfarrows,pgfnodes,pgfautomata,pgfheaps,pgfshade}
\usepackage{algorithm,algorithmic}
\usepackage{amsmath}
\usepackage{enumerate}
\usetheme{Air}

\makeatletter
\renewcommand*\env@matrix[1][*\c@MaxMatrixCols c]{%
  \hskip -\arraycolsep
  \let\@ifnextchar\new@ifnextchar
  \array{#1}}
\makeatother

\DeclareMathOperator*{\argmax}{arg\,max}

\title[CSC349A Numerical Analysis]{CSC349A Numerical Analysis}


\logo{\pgfputat{\pgfxy(-0.5,7.5)}{\pgfbox[center,base]{\includegraphics[width=1.0cm]{figures/uvic}}}}  
\beamertemplatenavigationsymbolsempty

    \defbeamertemplate{footline}{author and page number}{%
      \usebeamercolor[fg]{page number in head/foot}%
      \usebeamerfont{page number in head/foot}%
      \hspace{1em}\insertshortauthor\hfill%
      \insertpagenumber\,/\,\insertpresentationendpage\kern1em\vskip2pt%
    }
    \setbeamertemplate{footline}[author and page number]{}



\subtitle[Lecture 12]{Lecture 12}
\date[2023]{2023}
\author[R. Little]{Rich Little}
\institute[University of Victoria]{University of Victoria}
%\logo{\includegraphics[scale=.25]{unilogo.pdf}}
\begin{document}
\frame{\maketitle} % <-- generate frame with title


\AtBeginSection[]
{
\begin{frame}<beamer>[allowframebreaks]{Table of Contents}
\tableofcontents[currentsection,currentsubsection, 
    hideothersubsections, 
    sectionstyle=show/shaded,
]
\end{frame}
}

\section{Naive Gaussian Elimination}

\begin{frame}{Systems of Linear Equations}
\begin{itemize}
\item{Math background pg. 235-245}
\item{Review if necessary}
\begin{itemize}
\item{matrix notation}
\item{transpose}
\item{matirx operations - addition and multiplication}
\item{inverses, determinants}
\item{triangular matirces}
\end{itemize}
\item{For motivations in Engineering see Chapter 12 Case Studies - pg. 325-336}
\begin{itemize}
\item{Steady-state analysis of systems of reactors}
\item{Analysis of a statically determinate truss}
\item{Currents and voltages in resistor circuits}
\item{Spring-mass systems}
\end{itemize}
\end{itemize}
\end{frame}



\begin{frame}{Naive Gaussian Elimination}

{\bf Notation} for a system of $n$ linear equations in $n$ unknowns:

\[
Ax=b
\]

\noindent
where

\begin{itemize}
\item{$A$ is an $n \times n$ nonsingular matirx, and}
\item{$x$ and $b$ are column vectors with $n$ entries.}
\end{itemize}

\end{frame}

\begin{frame}{Naive Gaussian Elimination}

That is, given $A$ and $b$, solve for $x$ in

\begin{eqnarray*}
a_{11}x_1 +a_{12}x_2+ \dotsb +a_{1n}x_n &=&b_1 \\
a_{21}x_1 +a_{22}x_2+ \dotsb +a_{2n}x_n &=&b_2 \\
\vdots \\
a_{n1}x_1 +a_{n2}x_2+ \dotsb +a_{nn}x_n &=&b_n
\end{eqnarray*}

\noindent
or

\[
\begin{bmatrix}
    a_{11}       & a_{12} & \dots & a_{1n} \\
    a_{21}       & a_{22} & \dots & a_{2n} \\
    \vdots & \vdots & \ddots & \vdots \\
    a_{n1}       & a_{n2} & \dots & a_{nn}
\end{bmatrix}
\begin{bmatrix}
    x_{1} \\
    x_{2}  \\
    \vdots \\
    x_{n} 
\end{bmatrix}
=
\begin{bmatrix}
    b_{1} \\
    b_{2}  \\
    \vdots \\
    b_{n} 
\end{bmatrix}
\]

\end{frame}

\begin{frame}{Theoretical basis for Gaussian Elimination}
You can apply any of the following 3 elementary row operations to $Ax=b$ without
changing the solution.

\begin{enumerate}[i]
  \item multiply any equation $E_i$ by a nonzero constant $\lambda$
  \item replace equation $E_i$ by $E_i + \lambda E_j$
  \item interchange any two equations $E_i$ and $E_j$
\end{enumerate}

{\bf Naive Gaussian Elimination} uses operation \textcolor{orange}{ii}, only, to do the following:
\begin{enumerate}
  \item reduce the coefficient matrix $A$ to upper triangular form - {\bf forward elimination}
  \item solve the reduced matrix for $x$ - {\bf back-substitution}
\end{enumerate}

\end{frame}

\begin{frame}{Example 1 - Augmented matrix}
Solve for the following system of linear equations, with $n=3$, using Naive Gaussian Elimination.
\begin{eqnarray*}
x_1+x_2-x_3 &=& -2\\
2x_1-x_2+3x_3 &=& 14 \\
-x_1-2x_2+x_3 &=& 3
\end{eqnarray*}
\vspace{3 in}
\end{frame}

\begin{frame}{Example 1 - Forward elimination step 1}

\end{frame}

\begin{frame}{Example 1 - Forward elimination step 2}

\end{frame}

\begin{frame}{Example 1 - Back substitution}

\end{frame}


\begin{frame}{In General}

After forward elimination we have the augmented matrix

\[
\begin{bmatrix}[cccc|c]
    a_{11}       & a_{12} & \dots & a_{1n} & b_1 \\
    0       & a_{22}^{(1)} & \dots & a_{2n}^{(1)} & b_2^{(1)} \\
    \vdots & \vdots & \ddots & \vdots & \vdots \\
    0       & 0 & \dots & a_{nn}^{(n-1)} & b_n^{(n-1)}
\end{bmatrix}
\]

and then we back-substitute

\[
x_n = \frac{b_n^{(n-1)}}{a_{nn}^{(n-1)}}, x_i = \frac{b_i^{(i-1)} - \sum_{j=i+1}^{n} a_{ij}^{(i-1)}x_j}{a_{ii}^{(i-1)}}
\]

\end{frame}

\begin{frame}{Notes}
\begin{enumerate}
\item{When implemented we overwrite $A$ and $b$, thus no need for the superscripts.}
\item{Don't need to calculate, nor store the lower $0$'s.}
\item{The entries $a_{11}, a_{22}^{(1)}, a_{33}^{(2)}, ..., a_{n-1,n-1}^{(n-2)}$ are called the \underline{pivots}. 
They are the denominators in the multipliers - \underline{must be nonzero}}.
\end{enumerate}
\end{frame}

\section{Pseudocode for Naive Gaussian Elimination} 

\begin{frame}{Forward Elimination Pseudocode}
\begin{algorithm}[H]
\begin{algorithmic}[1]
\FOR{$k=1$ to $n-1$}
\FOR{$i=k+1$ to $n$}
\STATE $factor = a_{i,k} / a_{k,k}$
\FOR{$j=k+1$ to $n$}
\STATE $a_{i,j} = a_{i,j} - factor \times a_{k,j}$
\ENDFOR 
\STATE $b_i = b_i - factor \times b_k$
\ENDFOR
\ENDFOR
\end{algorithmic}
\caption{pseudocode for the calculation of forward elimination}
\label{alg:seq}
\end{algorithm}

\end{frame} 


\begin{frame}{Backward substitution pseudocode} 
\begin{algorithm}[H]
\begin{algorithmic}[1]
\STATE $x_n = b_n / a_{n,n}$
\FOR{$i=n-1$ to $1$}
\STATE $sum = b_i$
\FOR{$j=i+1$ to $n$}
\STATE $sum = sum - a_{i,j} \times x_j$
\ENDFOR 
\STATE $x_i = sum / a_{i,i}$ 
\ENDFOR
\end{algorithmic}
\caption{pseudocode for the calculation of back substitution}
\label{alg:seq}
\end{algorithm}

\end{frame} 

\section{Counting floating point operations} 

\begin{frame}{Floating-point operations}
The most common measure of the efficiency of algorithms for solving
linear systems $Ax =b$ is a floating-point operation (flop)
count. This is determined as a function of $n$, the order of the matrix
$A$.

The analysis uses the following identities: 
\begin{align*} 
\sum_{i=1}^{m} i = 1 + 2 + 3 + \dots + i = \frac{m(m+1)}{2} \\ 
\sum_{i=1}^{m} i^2 = 1^2 + 2^2 + 3^2 + \dots + i^2 = \frac{m(m+1)(2m+1)}{6}
\end{align*} 

Analysis of the Naive Gaussian Elimination algorithm: count the number
of floating point add/subtracts and multiplies/divides.
\end{frame}

\begin{frame}{Forward Elimination I} 

The forward elimination iterates over the rows of the matrix to
calculate the factors (or multipliers) and each time there is one less
row to consider. Therefore the number of divides is:
\[
(n-1) + (n-2) + \dots + 1 = \sum_{i=1}^{n-1} i = \frac{(n-1)n}{2} 
\]

For each one of these multipliers all the entries in the corresponding
row (except the zeros) are subtracted and multiplied. Therefore 
the number of subtractions and the number of multiplications are both: 

\[
(n-1)^2 + (n-2)^2 + \dots + 1^2 = \sum_{i=1}^{n-1} i^2 = \frac{(n-1)(n)(2n-1)}{6}
\]
\end{frame}

\begin{frame}{Foward Elimination II} 

We also have to do the corresponding subtracts and multiplies for $b$ both of which are: 

\[
(n-1) + (n-2) + \dots + (1) = \frac{(n-1)n}{2}
\]

Therefore the forward elimination totals are: 
\begin{align*} 
\mbox{number of mult/div} = \frac{2n^3 + 3n^2 -5n}{6} \\ 
\mbox{number of add/sub} = \frac{2n^3 - 2n}{6}
\end{align*} 
\end{frame}

\begin{frame}{Back substitution} 

We have one initial division followed by: 
\begin{align*}
 \mbox{number of subtracts} = 1 + 2 + \dots + (n-1) = \frac{(n-1)n}{2} \\ 
\mbox{number of multiplies} = 1 + 2 + \dots + (n-1) = \frac{(n-1)n}{2}
\end{align*} 
\noindent 
with the last number of divides being $n-1$. 

Therefore for back substituion the total is: 
\begin{align*}
\mbox{number of mult/div } = \frac{n^2+n}{2} \\ 
\mbox{number of add/sub } = \frac{n^2-n}{2}
\end{align*}
\end{frame}

\begin{frame}{Discussion} 
The purpose of the flop count is to give a measure of how computation
time increases as the problem size $n$ increases. For example, it can
help us determine that the forward elimination is much more time
consuming than the back substitution. 

For {\bf Forward elimination} we have
\[
\approx \frac{n^3}{3} + \frac{n^3}{3} = \frac{2n^3}{3} \mbox{flops} 
\] 
\noindent 
The notation $O(n^3)$ is used to indicate the order of increase with problem size without taking into account the constants. 

\end{frame}

\begin{frame}{Discussion II}

For {\bf Back substitution} we have 
\[
\frac{n^2 + n}{2} + \frac{n^2-n}{2} = n^2 
\]


For example, a $2n \times 2n$ linear system requires about 8 times the computation time than an $n \times n$ linear system 
as the cost of the forward elimination step would be 
\[
\frac{2(2n)^3}{3} = 8(\frac{2n^3}{3}).
\]

\end{frame} 

\end{document}


